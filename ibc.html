<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IBC reference UI</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/anchor-link@3.5.1/lib/anchor-link.bundle.js"></script>
  <script src="https://unpkg.com/anchor-link-browser-transport@3.5.1/lib/anchor-link-browser-transport.bundle.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
</head>

<body style="max-width:640px;margin:40px auto;">
  <div class="container" style="border:1px solid #64646d;padding:24px;">
    <h3 class="text-center">IBC</h3>
    <div class="flexRow"  style="margin-top:24px;">
      <select onchange="sourceChainChanged(this.value)" class="form-select chainSelect" id="sourceChain">
        <option value="" disabled selected>Select Chain</option>
      </select>
      <select class="form-select chainSelect" id="destinationChain" disabled>
        <option value="" disabled selected></option>
      </select>
    </div>
    <div class="flexRow" style="margin-top:24px;">
      <button style="display:none;" id="sourceLogin" onclick="login('source')" type="button" class="btn btn-success">Login</button>
      <button style="display:none;" id="sourceLogout" onclick="logout('source')" type="button" class="btn btn-danger">Logout</button>
      <button style="display:none;" id="destinationLogin" onclick="login('destination')" type="button" class="btn btn-success">Login</button>
      <button style="display:none;" id="destinationLogout" onclick="logout('destination')" type="button" class="btn btn-danger">Logout</button>
    </div>
    <hr>
    <div class="flexRow" style="margin-top:48px;">
      <div class="input-group"  style="width:260px;">
        <input id="amount" placeholder="Amount" type="number"class="form-control"></input>
        <div class="input-group-prepend">
          <select style="width:120px;" class="form-select tokenSelect" id="sourceAsset">
            <option value="" disabled selected>Token</option>
          </select>
        </div>
      </div>
      <button id="transferBtn" onclick="transfer()" disabled type="button" class="btn btn-primary">Transfer and Prove</button>
    </div>
    <div class="box">
      <div>Destination chain Bridge Schedule Version: <span id="lastProven"></span></div>
      <div>Source chain Active Schedule Version: <span id="activeSchedule"></span></div>
      <div>Source chain Pending Schedule: <span id="pendingSchedule"></span></div>
      <section id="status" style="margin-top:24px"></section>
    </div>
  </div>
</body>

<script>
  //chain Info;
  const chains = [{
    chainId: '73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d',
    nodeUrl: 'https://jungle4.api.eosnation.io',
    name: "jungle4",
    label: "Jungle 4 Testnet",
    proofSocket: "ws://138.201.202.27:27788",
    bridgeContract:"antelopeibc1",
    wrapLockContractsArray: ["antelopewlk1"],
    session:null,
    wrapLockContracts: [],
    symbols:null,
    auth:null,
  },{
    chainId: '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191',
    nodeUrl: 'https://api.kylin.alohaeos.com',
    name: "kylin",
    label: "Kylin Testnet",
    proofSocket: "ws://138.201.202.27:7788",
    bridgeContract:"antelopeibc1",
    wrapLockContractsArray: ["antelopewlk1"],
    session:null,
    wrapLockContracts: [],
    symbols:null,
    auth:null,
  }];

  let sourceChain, destinationChain, tokenRow, progress;
  fetchTokens();

  async function fetchTokens(){
    //fetch wraplock contracts tokens & details
    for (var chain of chains) {
      for (var wrapLockContract of chain.wrapLockContractsArray) {
        const result = await Promise.all([
          $.post(`${chain.nodeUrl}/v1/chain/get_table_rows`, JSON.stringify({ json: true, code: wrapLockContract, scope: wrapLockContract, table: 'global'})),
          $.post(`${chain.nodeUrl}/v1/chain/get_table_rows`, JSON.stringify({ json: true, code: wrapLockContract, scope: wrapLockContract, table: 'contractmap'}))
        ]);

        const global = result[0].rows[0];
        const contractMaps = result[1].rows;

        for (var map of contractMaps){
          let symbolsres = await $.post(`${chain.nodeUrl}/v1/chain/get_table_by_scope`, JSON.stringify({ code: map.native_token_contract, table: 'stat'}));
          let symbols = symbolsres.rows.map(r => toName(nameToUint64(r.scope)));
          console.log("symbols",symbols)
          chain.wrapLockContracts.push({
            chain_id: global.chain_id,
            wrapLockContract,
            nativeTokenContract: map.native_token_contract,
            pairedChainId: global.paired_chain_id,
            pairedWrapTokenContract: map.paired_wraptoken_contract,
            symbols
          });

        }

        // if (global.bridge_contract === chain.bridgeContract) {
        //   let symbolsres = await $.post(`${chain.nodeUrl}/v1/chain/get_table_by_scope`, JSON.stringify({ code: details.native_token_contract, table: 'stat'}));
        //   let symbols = symbolsres.rows.map(r => toName(nameToUint64(r.scope)));
        //   chain.wrapLockContracts.push({
        //     chain_id: details.chain_id,
        //     wrapLockContract,
        //     nativeTokenContract: details.native_token_contract,
        //     pairedChainId: details.paired_chain_id,
        //     pairedWrapTokenContract: details.paired_wraptoken_contract,
        //     symbols
        //   });
        // }
      }
    }
    //on DOM ready
    $(async function() {
      //add chain options to chain select elements
      for (var chain of chains) {
        $('#sourceChain').append(new Option(chain.label, chain.name));
        $('#destinationChain').append(new Option(chain.label, chain.name));
      }
    });
  }

  //handler for source chain change
  const sourceChainChanged = val =>{

    sourceChain = chains.find(c=>c.name==val);
    destinationChain = chains.find(c=>c.name !== val);
    $("#destinationChain").val(destinationChain.name);
    $('#sourceLogin').show();
    $('#destinationLogin').show();
    $('#lastProven').html("");
    $('#activeSchedule').html("");
    $('#pendingSchedule').html("");
    $('#status').html("");

    //set sourceChain symbols if not yet set
    if (!sourceChain.symbols) {
      let id = 1, nativeList = [], wrappedList = [];
      for (var row of sourceChain.wrapLockContracts) for (var symbol of row.symbols) {
        nativeList.push({ ...row, id, symbol, sourceTokenContract: row.nativeTokenContract, destinationTokenContract: row.pairedWrapTokenContract,  native: true });
        id++;
      }
      nativeList = nativeList.sort((a, b) => (a.symbol > b.symbol ? 1 : -1));

      id = 1000;
      for (var row of destinationChain.wrapLockContracts) for (var symbol of row.symbols) {
        wrappedList.push({ ...row, id, symbol, sourceTokenContract: row.pairedWrapTokenContract, destinationTokenContract: row.nativeTokenContract, native: false });
        id++;
      }
      wrappedList = wrappedList.sort((a, b) => (a.symbol > b.symbol ? 1 : -1));
      sourceChain.symbols = [...nativeList, ...wrappedList];
    }

    //clear Token select options
    $('#sourceAsset').find('option').remove().end();
    $('#sourceAsset').find('optgroup').remove().end();

    //set Token select options
    let optionsHtml = `<optgroup label="Native">`
    for (var r of sourceChain.symbols.filter(r=>r.native)) optionsHtml+=`<option value=${r.id}>${r.symbol}</option>`;
    optionsHtml+=`</optgroup><optgroup label="Wrapped">`;
    for (var r of sourceChain.symbols.filter(r=>!r.native)) optionsHtml+=`<option value=${r.id}>${r.symbol}</option>`;
    optionsHtml+=`</optgroup>`;
    $('#sourceAsset').append(optionsHtml);
  }

  //UI functions
  function login(type){
    const chain =  chains.find(c=>c.name===$(`#${type}Chain`).val());
    const link = new AnchorLink({
      transport: new AnchorLinkBrowserTransport(),
      chains: [{ chainId: chain.chainId, nodeUrl: chain.nodeUrl}]
    })
    link.login("IBC")
      .then((result) => {
        chain.session = result.session;
        chain.auth = { actor:chain.session.auth.actor.toString(), permission: chain.session.auth.permission.toString()}
        $(`#${type}Login`).hide();
        $(`#${type}Logout`).text(`Logout ${chain.auth.actor}@${chain.auth.permission}`);
        $(`#${type}Logout`).show();
        $(`#${type}Chain`).prop('disabled', true);
        $(`#transferBtn`).prop('disabled', chains.map(r=>r.session).includes(null));
      })
      .catch(ex=> alert(ex));
  }

  function logout(type){
    const chain =  chains.find(c=>c.name===$(`#${type}Chain`).val());
    chain.session?.remove();
    chain.session = null;
    chain.auth = null;
    $(`#${type}Logout`).hide();
    $(`#${type}Login`).show();
    if (!chains.find(c=>c.session) ) $(`#sourceChain`).prop('disabled', false);
    $(`#transferBtn`).prop('disabled', chains.map(r=>r.session).includes(null));
  }

  //transfer function to lock or retire tokens
  const transfer = async () => {
    //get values form UI
    tokenRow = sourceChain.symbols.find(r=>r.id===parseInt($('#sourceAsset').val()));
    let amount = parseFloat($("#amount").val());
    const quantity = `${amount.toFixed(4)} ${tokenRow.symbol}`;
    
    let sourceActions;
    if (tokenRow.native) sourceActions = [ transferToken({ tokenRow, sourceChain, destinationChain, quantity })]; //transfer token to the wraplock token
    else sourceActions = [ retireWrappedToken({ tokenRow, sourceChain, destinationChain, quantity }) ]; //retiring tokens from a non-native chain

    console.log("sourceActions",sourceActions)
    sourceChain.session.transact({actions: sourceActions}).then( async result => {
      console.log(result) // processed tx of transfer/retire
      const lockActionTrace = result.processed.action_traces.find(r=>r.act.name==='transfer' || r.act.name==='retire');
      const emitxferAction = lockActionTrace.inline_traces.find(r=>r.act.name==='emitxfer');
      console.log("emitxferAction to prove", emitxferAction);
      //Get schedule proofs;
      const scheduleProofs = await getScheduleProofs(result.processed.block_num);
      console.log("scheduleProofs",scheduleProofs)
      if (!scheduleProofs) return  $('#status').append(`<div><div>Error, no scheduleProofs</div><div class="progressDiv"></div>`);
      $('#status').append(`<div><div>Fetching proof for emitxfer...</div><div class="progressDiv"></div>`);
      const emitxferProof = await getProof({
        type: "heavyProof",
        action: emitxferAction,
        block_to_prove: emitxferAction.block_num //block that includes the emitxfer action we want to prove
      });
      
      console.log("emitxferProof",emitxferProof)

      //submit proof to destination chain's bridge contract
      let destinationActions = [...scheduleProofs, emitxferProof];

      console.log("destinationActions",destinationActions)
      $('#status').append(`<div>Submitting Proofs...</div>`);

      destinationChain.session.transact({actions: destinationActions}).then((result) => {
        console.log("result", result);
        $('#status').append(`<div style="margin-top:24px;"><a target="_blank" style="color:#1a8754" href="${destinationChain.nodeUrl}/tx/${result.processed.id}">TX ID<a></div>`);
      }).catch(async err=>{ 
        console.log("Error submitting transaction", err); 
        //TODO check type of error and if inline size, submit one by one
        // try{
        //   for (var action of destinationActions) {
        //     let txRes = await destinationChain.session.transact({actions: [action]});
        //     $('#status').append(`<div style="margin-top:24px;"><a target="_blank" style="color:#1a8754" href="${destinationChain.nodeUrl}/tx/${txRes.processed.id}">TX ID<a></div>`);
        //   }
        // }catch(ex){
        //   console.log("Error submitting transaction", ex);
        // }
      })
    })
  }

  const getScheduleProofs = async (transferBlock) => {
    async function getProducerScheduleBlock(blocknum) {
      try{
        const sourceAPIURL = sourceChain.nodeUrl+"/v1/chain";
        var header = await $.post(sourceAPIURL + "/get_block", JSON.stringify({"block_num_or_id":blocknum,"json": true}));
        let target_schedule = header.schedule_version;
        
        let min_block = 2;
        //fetch last proved block to use as min block for schedule change search 
        const lastBlockProved = await $.post(destinationChain.nodeUrl+ '/v1/chain/get_table_rows', JSON.stringify({
          code: destinationChain.bridgeContract,
          table: "lastproofs", 
          scope: sourceChain.name,
          limit: 1, reverse: true, show_payer: false, json: true
        }));

        if (lastBlockProved) min_block = lastBlockProved.rows[0].block_height;

        let max_block = blocknum;
        
        //detect active schedule change
        while (max_block - min_block > 1) {
          blocknum = Math.round((max_block + min_block) / 2);
          header = await $.post(sourceAPIURL + "/get_block", JSON.stringify({"block_num_or_id":blocknum,"json": true}));
          if (header.schedule_version < target_schedule) min_block = blocknum;
          else max_block = blocknum;
        }
        if (blocknum > 337) blocknum -= 337;
        //search before active schedule change for new_producer_schedule 
        let bCount = 0; //since header already checked once above
        while (blocknum < max_block && !("new_producer_schedule" in header)) {
          header = await $.post(sourceAPIURL + "/get_block", JSON.stringify({"block_num_or_id":blocknum,"json": true}));
          bCount++;
          blocknum++;
        }
        blocknum--;
        return blocknum;  
      }catch(ex){ console.log("getProducerScheduleBlock ex",ex); return null;}
    }

    const proofs = [];
    const bridgeScheduleData = await $.post(destinationChain.nodeUrl+ '/v1/chain/get_table_rows', JSON.stringify({
      code: destinationChain.bridgeContract,
      table: "schedules", 
      scope: sourceChain.name,
      limit: 1, reverse: true, show_payer: false, json: true
    }));
    
    var last_proven_schedule_version = 0;
    if (bridgeScheduleData.rows.length > 0) last_proven_schedule_version = bridgeScheduleData.rows[0].producer_schedule.version;
    if (!last_proven_schedule_version) return console.log('No Schedule Found in Contract!');

    let schedule = (await $.get(sourceChain.nodeUrl+ '/v1/chain/get_producer_schedule'));
    var schedule_version = parseInt(schedule.active.version);

    //update UI schedule status
    $("#lastProven").html("v"+last_proven_schedule_version);
    $("#activeSchedule").html("v"+schedule_version);
    if (schedule.pending) $('#pendingSchedule').html("YES"); else $('#pendingSchedule').html("NO"); 

    let schedule_block = transferBlock + 0;
    while (schedule_version > last_proven_schedule_version) {
      $('#status').append(`<div><div>Locating block header with producer schedule (v${schedule_version})...</div><div class="progressDiv"></div>`);
      let block_num = await getProducerScheduleBlock(schedule_block);
      if (!block_num) return; //should never occur
      $('#status').append(`<div><div>Fetching proof for active schedule (v${schedule_version})...</div><div class="progressDiv"></div>`);
      var proof = await getProof({block_to_prove: block_num});
      schedule_version = proof.data.blockproof.blocktoprove.block.header.schedule_version;
      schedule_block = block_num;
      proofs.unshift(proof);
    };

    // check for pending schedule and prove pending schedule if found;
    if (schedule.pending) {
      $('#status').append(`<div><div>Fetching proof for pending schedule...</div><div class="progressDiv"></div>`);

      let newPendingBlockHeader=null;
      let currentBlock = transferBlock + 0;
      while(!newPendingBlockHeader){
        let bHeader = (await $.post(`${sourceChain.nodeUrl}/v1/chain/get_block`, JSON.stringify({ block_num_or_id: currentBlock })));
        if (bHeader['new_producer_schedule']) newPendingBlockHeader = bHeader;
        else currentBlock--;
      }
      var pendingProof = await getProof({block_to_prove: newPendingBlockHeader.block_num});
      proofs.push(pendingProof); //push pending after proving active
    } 

    return proofs;
  };

  const getProof = ({type="heavyProof", block_to_prove, action}) => {
    return new Promise(resolve=>{
      //initialize socket to proof server
      const ws = new WebSocket(sourceChain.proofSocket);
      let prog = 1;
      let progressInterval; 
      ws.addEventListener('open', (event) => {
        // connected to websocket server
        const query = { type, block_to_prove };
        if (action) query.action_receipt = action.receipt;
        ws.send(JSON.stringify(query));
        
        if (action) progressInterval = setInterval(()=>{
          $('.progressDiv').last().html(prog +"%");
          prog++
        },2000)
      });

      //messages from websocket server
      ws.addEventListener('message', (event) => {
        const res = JSON.parse(event.data);
        //log non-progress messages from ibc server
        if (res.type !=='progress') console.log("Received message from ibc proof server", res);
        if (res.type =='progress') {
          if (progressInterval) clearInterval(progressInterval);
          $('.progressDiv').last().html(res.progress +"%");
        }
        if (res.type !=='proof') return;
        ws.close();
        $('.progressDiv').last().html("100%");

        //handle issue/withdraw if proving transfer/retire 's emitxfer action, else submit block proof to bridge directly (for schedules)
        const actionToSubmit = { 
          authorization: [destinationChain.auth],
          name: !action ? "checkproofa" : tokenRow.native ? "issuea" : "withdrawa",
          account: !action ? destinationChain.bridgeContract : tokenRow.native ? tokenRow.pairedWrapTokenContract : tokenRow.wrapLockContract,
          data: { ...res.proof, prover: destinationChain.auth.actor } 
        };

        //if proving an action, add action and formatted receipt to actionproof object
        if (action) {
          actionToSubmit.data.actionproof = {
            ...res.proof.actionproof,
            action: {
              account: action.act.account,
              name: action.act.name,
              authorization: action.act.authorization,
              data: action.act.hex_data
            },
            receipt: { ...action.receipt, auth_sequence: [] },
          }
          if(action.receipt.auth_sequence && action.receipt.auth_sequence.length){
            for (var authSequence of action.receipt.auth_sequence)  actionToSubmit.data.actionproof.receipt.auth_sequence.push({
              account: authSequence[0],
              sequence: authSequence[1]
            })
          }
        }
        resolve(actionToSubmit);
      });
    });
  }

  //action creation functions
  const transferToken = ({tokenRow, sourceChain, destinationChain, quantity} ) => ({
    account: tokenRow.nativeTokenContract,
    name: "transfer",
    authorization: [sourceChain.auth],
    data: {
      from: sourceChain.auth.actor,
      to: tokenRow.wrapLockContract,
      quantity,
      memo: destinationChain.auth.actor
    }
  });

  const retireWrappedToken = ({ tokenRow, sourceChain, destinationChain, quantity }) => ({
    account: tokenRow.sourceTokenContract,
    name: "retire",
    authorization: [sourceChain.auth],
    data: {
      owner: sourceChain.auth.actor,
      quantity,
      beneficiary: destinationChain.auth.actor
    }
  });

  //eosio name helper functions
  const char_to_symbol = (c) => {
    if (typeof c == 'string') c = c.charCodeAt(0);
    if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) return c - 'a'.charCodeAt(0) + 6;
    if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) return c - '1'.charCodeAt(0) + 1;
    return 0;
  };

  const toName = (value) => {
    let v = BigInt.asUintN(64, value);
    let result = '';
    while (v > 0) {
      const c = v & BigInt(0xff);
      result += String.fromCharCode(Number(c.toString()));
      v >>= 8n;
    }
    return result;
  };

  const nameToUint64 = (s) => {
  let n = 0n;
  let i = 0;
  for (; i < 12 && s[i]; i++) n |= BigInt(char_to_symbol(s.charCodeAt(i)) & 0x1f) << BigInt(64 - 5 * (i + 1));
  if (i == 12) n |= BigInt(char_to_symbol(s.charCodeAt(i)) & 0x0f);
  return n.toString();
};
</script>

<style>
  html,body{ background-color: #31313d; color:white; font-family: Verdana, Geneva, Tahoma, sans-serif; }
  .flexRow{ display: flex; align-items: center; justify-content: space-between;}
  label{ width:70px; text-align: left;color:white; }
  .form-select, .form-control, button{ width:272px; }
  .form-select:disabled { background-color: #adafb2; }
  .box{ padding:16px; border:1px solid #64646d;margin-top:44px; }
  .box > div, #status > div{ display:flex; justify-content: space-between; }
</style>
</html>